import { GeminiService } from './geminiService';
import { GeminiModelVersion } from '../types/settings';

// ƒê·ªãnh nghƒ©a c√°c ch·ªß ƒë·ªÅ TOEIC c∆° b·∫£n
export const TOEIC_TOPICS = [
  { id: 'business', name: 'Kinh doanh & VƒÉn ph√≤ng', icon: 'üíº' },
  { id: 'technology', name: 'C√¥ng ngh·ªá & Internet', icon: 'üíª' },
  { id: 'travel', name: 'Du l·ªãch & Giao th√¥ng', icon: '‚úàÔ∏è' },
  { id: 'health', name: 'S·ª©c kh·ªèe & Y t·∫ø', icon: 'üè•' },
  { id: 'education', name: 'Gi√°o d·ª•c & ƒê√†o t·∫°o', icon: 'üìö' },
  { id: 'entertainment', name: 'Gi·∫£i tr√≠ & Th·ªÉ thao', icon: 'üéÆ' },
  { id: 'environment', name: 'M√¥i tr∆∞·ªùng & Thi√™n nhi√™n', icon: 'üåø' },
  { id: 'finance', name: 'T√†i ch√≠nh & Ng√¢n h√†ng', icon: 'üí∞' },
  { id: 'food', name: '·∫®m th·ª±c & Nh√† h√†ng', icon: 'üçΩÔ∏è' },
  { id: 'shopping', name: 'Mua s·∫Øm & D·ªãch v·ª•', icon: 'üõçÔ∏è' }
];

export interface TopicVocabularyResponse {
  success: boolean;
  vocabularyList?: Array<{
    word: string;
    meaning: string;
    ipa: string;
    example: string;
    topic: string;
  }>;
  error?: string;
}

export class ToeicVocabularyService {
  private geminiService: GeminiService;

  constructor(apiKey: string, modelVersion: GeminiModelVersion) {
    this.geminiService = new GeminiService(apiKey, modelVersion);
  }

  private generateTopicPrompt(topic: string): string {
    return `Generate 10 essential TOEIC vocabulary words for the topic "${topic}" in Vietnamese. Response must be in this exact JSON format:
{
  "vocabularyList": [
    {
      "word": "example word",
      "meaning": "nghƒ©a ti·∫øng Vi·ªát",
      "ipa": "/pronunciation/",
      "example": "Example sentence using the word in business context"
    }
  ]
}

Requirements:
1. Words must be commonly used in TOEIC tests and business settings
2. Examples must be in business/professional context
3. Vietnamese meanings must be clear and accurate
4. IPA must be correct
5. All words must be relevant to the topic "${topic}"
6. Response must be valid JSON format
7. Each word must be unique
8. Each word must be a single word or common compound word
9. Do not include any markdown or text outside the JSON
10. Do not include any explanations or notes`;
  }

  private extractJsonFromText(text: string): string | null {
    console.log("=== Raw Response ===");
    console.log(text);
    console.log("==================");

    // T√¨m chu·ªói JSON h·ª£p l·ªá b·∫Øt ƒë·∫ßu b·∫±ng { v√† k·∫øt th√∫c b·∫±ng }
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      console.log("Kh√¥ng t√¨m th·∫•y chu·ªói JSON h·ª£p l·ªá trong response");
      return null;
    }

    const jsonStr = jsonMatch[0];
    console.log("=== Extracted JSON ===");
    console.log(jsonStr);
    console.log("=====================");

    // Ki·ªÉm tra xem chu·ªói JSON c√≥ h·ª£p l·ªá kh√¥ng
    try {
      JSON.parse(jsonStr);
      return jsonStr;
    } catch (error) {
      console.log("Chu·ªói JSON kh√¥ng h·ª£p l·ªá:", error);
      return null;
    }
  }

  private validateVocabularyItem(item: any): boolean {
    return (
      typeof item.word === 'string' &&
      typeof item.meaning === 'string' &&
      typeof item.ipa === 'string' &&
      typeof item.example === 'string' &&
      item.word.trim() !== '' &&
      item.meaning.trim() !== '' &&
      item.ipa.trim() !== '' &&
      item.example.trim() !== ''
    );
  }

  public async generateVocabularyForTopic(topic: string): Promise<TopicVocabularyResponse> {
    try {
      console.log(`B·∫Øt ƒë·∫ßu t·∫°o t·ª´ v·ª±ng cho ch·ªß ƒë·ªÅ: ${topic}`);
      const prompt = this.generateTopicPrompt(topic);
      
      const response = await this.geminiService.generateContent(prompt);
      
      if (!response) {
        console.log("Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ Gemini API");
        throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ AI');
      }

      const jsonStr = this.extractJsonFromText(response);
      if (!jsonStr) {
        throw new Error('Kh√¥ng th·ªÉ tr√≠ch xu·∫•t JSON t·ª´ ph·∫£n h·ªìi');
      }

      // Parse and validate response
      const parsedResponse = JSON.parse(jsonStr);
      
      if (!parsedResponse.vocabularyList || !Array.isArray(parsedResponse.vocabularyList)) {
        console.log("Response thi·∫øu tr∆∞·ªùng vocabularyList ho·∫∑c kh√¥ng ph·∫£i array");
        throw new Error('ƒê·ªãnh d·∫°ng ph·∫£n h·ªìi kh√¥ng h·ª£p l·ªá');
      }

      // Validate each vocabulary item
      const validVocabulary = parsedResponse.vocabularyList.filter(
        (item: any) => this.validateVocabularyItem(item)
      );

      if (validVocabulary.length === 0) {
        throw new Error('Kh√¥ng c√≥ t·ª´ v·ª±ng h·ª£p l·ªá ƒë∆∞·ª£c t·∫°o');
      }

      // Remove duplicates based on word (case insensitive)
      const uniqueVocabulary = validVocabulary.filter(
        (item: any, index: number, self: any[]) =>
          index === self.findIndex((t: any) => 
            t.word.toLowerCase() === item.word.toLowerCase()
          )
      );

      // Add topic to each vocabulary item
      const vocabularyWithTopic = uniqueVocabulary.map((vocab: any) => ({
        ...vocab,
        word: vocab.word.trim(),
        meaning: vocab.meaning.trim(),
        ipa: vocab.ipa.trim(),
        example: vocab.example.trim(),
        topic
      }));

      console.log(`ƒê√£ t·∫°o th√†nh c√¥ng ${vocabularyWithTopic.length} t·ª´ v·ª±ng`);
      return {
        success: true,
        vocabularyList: vocabularyWithTopic
      };
    } catch (error) {
      console.error("L·ªói khi t·∫°o t·ª´ v·ª±ng:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'L·ªói kh√¥ng x√°c ƒë·ªãnh'
      };
    }
  }
} 